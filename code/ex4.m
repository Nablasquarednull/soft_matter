
%% FJC Monte Carlo - MULTIPLE FORCES VERSION

clear; clc; close all;

% Parameters 
N = 100;           % Number of bonds
b = 1.0;           % Bond length [nm]
kbT = 1.0;         % Thermal energy [pN·nm]
n_steps = 10000;    % MC steps per force value
eq_steps = 400;    % Equilibration steps
n_skip = 10;       
output_folder = 'mc_frames';

% Force values to test 
Fx_values = [0.0, 0.5, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 8.0, 10.0];
n_forces = length(Fx_values);

% Results storage
Qx_avg = zeros(n_forces, 1);
Qx_std = zeros(n_forces, 1);

% MAIN LOOP OVER FORCES
for f_idx = 1:n_forces
    Fx = Fx_values(f_idx);
    F_vec = [Fx; 0; 0];
    
    fprintf('\n=== Force Fx = %.1f pN (%.0f/%d) ===\n', ...
            Fx, f_idx, n_forces);
    
    [U_history, Q_history] = extendPolymer(Fx, N, b, kbT, ... 
        n_steps, n_skip, output_folder);

    Qx_history = Q_history(:,1);

    
    % Store results
    %Qx_avg(f_idx) = mean(Qx_history(eq_steps+1:end));
    %Qx_std(f_idx) = std(Qx_history(eq_steps+1:end));
    Qx_avg(f_idx) = mean(Qx_history);
    Qx_std(f_idx) = std(Qx_history);
    %Qx_avg(f_idx) = mean(Qx_history(end));
    %Qx_std(f_idx) = std(Qx_history(end));



    
    fprintf('Average Qx = %.2f ± %.2f nm\n', Qx_avg(f_idx), Qx_std(f_idx));
end

%% Plot force vs extension
figure;
%errorbar(Fx_values, Qx_avg, Qx_std, 'bo-', 'LineWidth', 1.5, 'MarkerSize', 8);
plot(Qx_avg ./ (N * b), Fx_values, 'b*',  'MarkerSize', 8)
ylabel('Force F (pN)');
xlabel('Extension ⟨Q_x⟩ (nm)');
title('Force-Extension Curve: FJC Polymer');
grid on;

%% Compare with theory
alpha = Fx_values * b / kbT;
Qx_theory = N * b * (coth(alpha) - 1./alpha);
hold on;
plot(Qx_theory ./ (N * b), Fx_values, 'r--', 'LineWidth', 2);
legend('Monte Carlo Simulation', 'Theoretical FJC', 'Location', 'NorthWest');

%% Compare Qx with theory
alpha = Fx_values * b / kbT;
Qx_theory = N * b * (coth(alpha) - 1./alpha);
hold on;
plot(Qx_theory ./ (N * b), Fx_values, 'r--', 'LineWidth', 2);
legend('Monte Carlo Simulation', 'Theoretical FJC', 'Location', 'NorthWest');

figure;

alpha = Fx_values(end) * b / kbT;
Q_thermal = N*b * (coth(alpha) - (1/alpha));

hold on
plot(1:n_steps, Qx_history, LineWidth=1.5)
yline(Q_thermal,'r--')
legend('Simulation', ' | < Q , u_x > |', 'Location', 'SouthEast');
ylabel('Q_x');
xlabel('Steps');








function [U_register, Q_register] = extendPolymer(Fx, N, b, kbT, n_steps, n_skip, output_folder)

    % Initialize Polymer 
    % Random initial chain (uniform on sphere)
    bond_vecs = zeros(3, N);
    for i = 1:N
        % Correct method for uniform random on sphere
        while true
            vec = 2*rand(3,1) - 1;  % Random in [-1,1]^3
            if norm(vec) <= 1       % Inside unit sphere
                break;
            end
        end
        vec = vec / norm(vec);      % Normalize to unit sphere
        bond_vecs(:, i) = b * vec;  % Scale to bond length
    end
    
    % Compute monomer positions
    monomers = zeros(3, N+1);
    for i = 1:N
        monomers(:, i+1) = monomers(:, i) + bond_vecs(:, i);
    end
    
    % Force Parameters 
    %Fx = 5.0;  % A force along x-axis is applied [pN] units
    F_vec = [Fx; 0; 0];
    
    % Initialize Energy
    Q_vec = sum(bond_vecs, 2);  % End-to-end vector
    U = -dot(F_vec, Q_vec); % Potential energy
    Q_register = zeros(n_steps,3);
    U_register = zeros(n_steps,3);
    % Monte Carlo  
    %{
    Monte Carlo simulation is a meta heuristic algorithm, that is inspired by 
    thermodynamics. It produces a random perturbation on the chain, for this
    perturbation to be accepted as physicaly probable, a new potential energy
    must be created, this change must agree with the ones generated by thermal
    fluctuations, in other words, the difference between the old and new
    potential energy mus be lesser than exp(-dU/KbT)
    %}
    fprintf('Running Monte Carlo simulation...\n');
    fprintf('Force Fx = %.2f pN\n', Fx);
    fprintf('Frames: %d \n', floor(n_steps/n_skip));
    
    frame_count = 0;
    for step = 1:n_steps
        % Randomly choose a bond to perturb
        idx = randi(N);
        
        % Generate a new random direction 
        new_dir = randn(3,1);
        new_dir = new_dir / norm(new_dir);
        new_bond = b * new_dir;
        
        % Propose a new chain
        proposed_bonds = bond_vecs;
        proposed_bonds(:,idx) = new_bond;
        
        % New end-to-end vector and energy
        Q_proposed = sum(proposed_bonds, 2);
        U_proposed = -dot(F_vec, Q_proposed);
        
        % Metropolis acceptance criterion
        dU = U_proposed - U;
        if dU < 0
            accept = true;
        else
            accept = (rand < exp(-dU/kbT));
        end
        
        % Update if accepted
        if accept
            bond_vecs = proposed_bonds;
            Q_vec = Q_proposed;
            U = U_proposed;
            
            % Recompute monomer positions
            monomers = zeros(3, N+1);
            for i = 1:N
                monomers(:, i+1) = monomers(:, i) + bond_vecs(:, i);
            end
        end
        
        % Save frames
        % For the sake of the memory disk, only certain frames are saved. 
        % Whenever the frame number hits n_skip, the frame is saved.
    
        if mod(step, n_skip) == 0
            frame_count = frame_count + 1;
            
            % Write XYZ file 
            filename = sprintf('%s/mc_frame_%04d.xyz', output_folder, frame_count);
            fid = fopen(filename, 'w');
            
            % Adding a header, just in case 
            fprintf(fid, '%d\n', N+1);
            fprintf(fid, 'MC Step %d, Fx=%.2f pN, Energy=%.3f kBT\n', ...
                    step, Fx, U/kbT);
            
            % Atom coordinates
            for i = 1:N+1
                fprintf(fid, 'C %12.6f %12.6f %12.6f\n', ...
                        monomers(1, i), monomers(2, i), monomers(3, i));
            end
            
            fclose(fid);
        end
        
        % Progress
        if mod(step, 100) == 0
            fprintf('  Step %d/%d, Qx = %.2f nm\n', step, n_steps, Q_vec(1));
        end
        Q_register(step, :) = Q_vec';
        U_register(step, :) = U';
    end
    
    % Create Trajectory
    
    traj_filename = 'mc_trajectory.xyz';
    fid_traj = fopen(traj_filename, 'w');
    
    for frame = 1:frame_count
        frame_file = sprintf('%s/mc_frame_%04d.xyz', output_folder, frame);
        fid = fopen(frame_file, 'r');
        
        % Copy entire frame
        while ~feof(fid)
            line = fgetl(fid);
            fprintf(fid_traj, '%s\n', line);
        end
        
        fclose(fid);
    end
    fclose(fid_traj);
    


end

%% Analysis on the end to end vector Qx 





%% Functions 
function [X,Y,Z] = readXYZ(filename, T, N)

    fiD = fopen(filename, 'r') ;
    X = zeros(T,N + 1);
    Y = zeros(T,N + 1);
    Z = zeros(T,N + 1);
    % OUTPUT
    for t = 1:T
        fgetl(fiD) ; %Line 1 101
        fgetl(fiD) ; %Line 2 t = 1

        for i = 1:N+1
            line = fgetl(fiD); %This will give me a string
            data = strsplit(line); %This is gonna split the string
            X(t, i) = str2double(data(2));
            Y(t, i) = str2double(data(3));
            Z(t, i) = str2double(data(4)); 

        end 

    end


end
